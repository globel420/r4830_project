# agent.md — R48xx / ChargeFast BLE Controller Project

## 0) What this project is
You’re reverse-engineering a BLE-controlled high-voltage charger (advertised/seen as “ChargeFast”, also “go slow” name variants) by **replaying exact BLE write payloads** captured from Android `btsnoop_hci.log` bugreports.

Key rule: **No guessing. No “protocol theory.”**  
We only:
1) capture real traffic,
2) isolate payloads,
3) name them in a definitions file,
4) build a controller that can replay them reliably with keepalive + telemetry polling.

Target platforms:
- **macOS app** (primary)
- **iPhone app** (also required)
- maybe Android later (port-friendly)

You explicitly do **not** want a “web app” UI as the final product.

---

## 1) BLE discovery summary (GATT)
From the BLE services view you reported:

You have three 16-bit UUID items showing under “Services”:
- **0xFFE2** has: *Indicate, Notify, Read, Write, Write Without Response*
- **0xFFE3** has: *Write, Write Without Response*
- **0xFFE1** exists (no properties shown in list view)

This matches a very common “UART-like custom BLE service” pattern:
- **FFE3** = command TX (client writes commands)
- **FFE2** = status / telemetry RX (device notifies/indicates; sometimes also accepts writes)
- **FFE1** = sometimes a service container / descriptor / legacy characteristic

Full 128-bit form commonly used by BLE stacks:
- `0000FFE2-0000-1000-8000-00805F9B34FB`
- `0000FFE3-0000-1000-8000-00805F9B34FB`
(and same for other 16-bit items)

---

## 2) Where the truth comes from (your capture pipeline)
You are capturing BLE traffic from Android via:
- `adb bugreport` → pulls `dumpstate-*.zip`
- unzip → locate `FS/data/log/bt/btsnoop_hci.log`
- `tshark` filters **ATT Write Request** payloads:
  - `btatt.opcode == 0x52` (ATT Write Request)
  - observed handle used heavily: **0x0006**

You built a script to repeatedly capture after making **one controlled UI change** in the OEM app, then map unique payloads and timelines:
- This is how you prove payload ↔ setting change.

You have repeatedly done “single variable” tests. The project should assume:
- Each setting’s command(s) can be isolated.
- The definitions file is the canonical memory.

---

## 3) Handles + payload evidence (what we have *actually seen*)
From the recent captures you printed, for writes on:
- **handle 0x0006**
- **opcode 0x52**
the most common payloads include:

### 3.1 “Keepalive / heartbeat”
- `020606`  
This appears **hundreds+ times** per session (examples: 694, 895, 1120 occurrences).
Interpretation: periodic keepalive/heartbeat required to maintain session / prevent disconnect / keep telemetry flowing.

### 3.2 Other common “session/setup” writes (non-06..)
Seen repeatedly at session start:
- `2302443431443843443938463030423230344539`
- `38303039393845434638343237450045`
- `020101`
- `020404`
- `020505`

These likely represent:
- app handshake / identity / mode select
- feature flags / request telemetry
- not proven yet (but consistent across sessions)

### 3.3 “Interesting commands” (06.. prefix)
These are the key ones you’re mapping and want in the definitions file. Observed (from your `uniq` output across multiple captures):

- `06080000803fc7`
- `06080000003f47`
- `060b010000000c`
- `060b000000000b`
- `060c010000000d`
- `060c000000000c`
- `06130000000013`
- `06140100000015`
- `06140000000014`
- `06150000004156`
- `06150000803fd4`
- `06200000000020`
- `06200100000021`
- `0621000016437a`
- `06220000003f61`
- `06230000000023`
- `06230100000024`
- `06070000164360`
- `06070000174361`
- `0607000013435d`
- `06070000803fc6`

What this implies:
- This charger’s command family likely starts with `0x06` and ends with a checksum/terminator pattern (many end with `..0b`, `..0c`, `..0d`, `..13`, etc.).
- You’re not decoding the protocol; you’re replaying and labeling.

---

## 4) Mapping strategy (how we decide what each command “means”)
You want a single **definitions file** where each command is:
- one line (or one entry),
- has a short name,
- contains the raw hex payload,
- has notes about when it appears / what UI change triggers it,
- includes optional parameterization rules (later, once proven).

Process:
1) Set only one UI value (toggle / increment / decrement)
2) Capture bugreport immediately
3) Extract the set of `06..` payloads added/changed vs baseline
4) Name them in definitions:
   - `two_stage_enable_on`
   - `two_stage_enable_off`
   - `manual_control_open`
   - `manual_control_close`
   - `set_stage2_voltage_150v`
   - etc.

Important: some settings may require multiple writes (confirm + apply + commit).
So a “logical command” might be a sequence:
- write A
- write B
- then keepalive continues

Definitions should support both:
- single payload commands
- multi-payload “macro” sequences

---

## 5) Runtime behavior requirements (the controller logic)
Regardless of UI:
- Must connect to the device
- Must subscribe to telemetry (likely on **FFE2 notify/indicate**)
- Must continuously send keepalive `020606` at a safe interval
- Must allow sending any command payload by name (from definitions)
- Must allow sending raw hex for testing

Operational flow:
1) Scan for BLE device by name / partial name (“ChargeFast”)
2) Connect
3) Discover services/characteristics
4) Identify characteristic(s) for:
   - TX write: likely **FFE3**
   - RX notify: likely **FFE2**
5) Enable notifications on RX characteristic
6) Start keepalive loop (e.g., 1–3s until proven)
7) Provide command send API (by definition key)
8) Provide telemetry monitor / logging and optional polling commands if needed

---

## 6) Project structure decisions (simplified)
You rejected a split `/backend` + `/frontend` web-style architecture.

The simplest structure for where you’re at now is:

- `controller/`
  - `backend/` (BLE engine + definitions + test CLI)
  - `apps/` (future)
    - `macos/` (future)
    - `ios/` (future)
    - `android/` (future)

BUT: you also said you already created:
- `/Users/globel/r4830_project/controller/` as the base

So: treat `controller/` as the repo root and keep it clean.

---

## 7) UI plan (macOS + iPhone without “web”)
Best path to avoid rewriting UI twice:
- **Flutter** single codebase (macOS + iOS + Android later)

Two viable architectures:

### Option A (recommended): Flutter does BLE directly
- Flutter UI + Flutter BLE plugin
- Reads `ble_definitions.yaml` bundled as asset
- Sends commands + keepalive + telemetry within the app

Pros:
- Single codebase
- No separate Python runtime
- Easier to ship to iPhone

Cons:
- BLE plugins can have edge cases; needs careful testing

### Option B: Python BLE engine on macOS only, Flutter UI talks to it
- macOS app uses local Python engine
- iPhone cannot run that Python engine, so iOS still needs native/Flutter BLE

Pros:
- Faster iteration on macOS
Cons:
- Architecture split across platforms

Given your “build once, run everywhere” goal:
- **Option A is smartest long-term.**

---

## 8) Known issues you hit (and fixes)
### 8.1 zsh: event not found: /usr/bin/env
This error is caused by **zsh history expansion**. The most common cause is a `!` character in the text you pasted into the shell (zsh tries to expand it as history).

Example triggers:
- Markdown with `#!/usr/bin/env ...` is usually fine,
- but a pasted block that contains `!` anywhere (like “Important!” or “!/usr/bin/env”) will explode.

Fix options:
- Run a script from a file (don’t paste)
- Or temporarily disable history expansion:
  - `set +H`  (or `setopt NO_HIST_SUBST`)
- Or escape `!` as `\!`

Project rule:
- Prefer generating scripts as files + `chmod +x` over pasting large blocks.

---

## 9) What the definitions file must contain (your requirement)
You requested:
- A “short hand log / definition file” with **all commands we know**
- so you never redo mapping work again

Minimum fields per command entry:
- `key`: stable identifier (snake_case)
- `hex`: payload
- `handle` (if known) and/or characteristic UUID (preferred)
- `write_type`: `write` vs `write_without_response` (if known)
- `notes`: what UI change produced it
- `tags`: categories like `keepalive`, `telemetry`, `two_stage`, `manual_control`, `security`, etc.
- `sequence`: optional list for multi-step macros

Also include:
- `known_keepalive_hex: 020606`
- device/service UUIDs: FFE2/FFE3/FFE1
- recommended keepalive interval (until proven)

---

## 10) What we still need to finish cleanly (known unknowns)
Even with lots of payload mapping, two things still matter to make a controller “real”:

1) **Which characteristic is TX and which is RX** on the actual device
   - Your service-property hint suggests:
     - TX = FFE3 (write)
     - RX = FFE2 (notify/read)
   - But we should confirm by connecting and enumerating characteristics.

2) **Telemetry format**
   - Once RX notifications are captured, we can:
     - log raw bytes
     - label fields as you identify them (voltage/current/temp/state)
   - This becomes the “telemetry definitions” section.

---

## 11) Practical operating checklist (how you work this project)
When mapping a new setting:
1) Start from a known baseline in the OEM app
2) Change **one thing**
3) Run capture script
4) Compare new `06..` payloads vs baseline
5) Add/rename in definitions
6) Replay payload from controller to confirm it has same effect

When building the controller:
- Don’t “interpret”; just replay
- Keepalive always on while connected
- Telemetry stream always on while connected
- Log everything

---

## 12) Current deliverable expectation (next step)
You asked for:
- a script runnable from `controller/` that:
  - builds folder structure,
  - writes backend files,
  - includes **complete definitions**.

And you asked for:
- a zip bundle you can unzip.

This agent.md is the canonical project memory.
The **definitions file** is the canonical command memory.

---

## Appendix A — Observed “06..” command list (canonical so far)
(These are observed in your printed outputs; mapping to meaning is still “WIP labels” until fully confirmed.)

- 06070000164360
- 06070000174361
- 0607000013435d
- 06070000803fc6
- 06080000803fc7
- 06080000003f47
- 060b010000000c
- 060b000000000b
- 060c010000000d
- 060c000000000c
- 06130000000013
- 06140100000015
- 06140000000014
- 06150000004156
- 06150000803fd4
- 06200000000020
- 06200100000021
- 0621000016437a
- 06220000003f61
- 06230000000023
- 06230100000024

Appendix B — Observed keepalive
- 020606

Appendix C — Repeated handshake-ish packets (seen at session start)
- 2302443431443843443938463030423230344539
- 38303039393845434638343237450045
- 020101
- 020404
- 020505
